# Run

`go run ./cmd -mode=server` to run server
`go run ./cmd -mode=client -ip=*server ip*` to run client
`make (loss|rate|corrupt)` to run tests with pumba

# Описание

Есть обертка над UDP, которая дает нам простой сервер, который имеет тупо метод "получить пакет" (обернутый в "соединение")  
А так же "соединение", которое по сути представляет сокет + методы `send/receive` (в случае серверного соединения, `receive` работает только 1 раз и читает из внутреннего буфера)

У соединения есть интерфейс, который позволяет мокнуть его и добавить каких-нибудь фич, типа `LoggingConn` логгирования всех пакетов, `RandomFailureConn` рандомной потери пакетов или `MixingFailureConn` перемешивания пакетов.

И на основе этого интерфейса (и сервера) есть пакет TCP, который так же дает сервер и соединение. Тут соединение уже правильное - можно отправлять и получать пакеты и с клиента и с сервера. Сервер же умеет кидать новых клиентов в канал (см. тесты/запуск сервера)

Помимо этого есть тест echo сервера на UDP, а так же несколько мок тестов для TCP - с потерей пакетов, а так же с перемешиванием  
Чтобы запустить их - `go test ./tcp -v -count=1` (или udp). Можно еще включить логгирование в файле тестов (`tcp_test.go`) - нужно откомментить строки с `mock.NewLogging()`

Для тестирования из задания все это засовывается в докер на основе гошного образа, и запускается просто соответствующий скрипт из `testing`  
Тестирование работает методом того, что на эхо сервер шлется файл, получается с него ответ, и сверяется, что получили то же самое, что отправили  
Если получили бяку - завершаем тестирование, так что логи перестанут писаться. Если логи пишутся (там еще с паузой пишется `TEST SUCCESSFUL`), значит все работает

Ну и поверх этого запускается пумба и портит соединения, а мы пытаемся выжить
